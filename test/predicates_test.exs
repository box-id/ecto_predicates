defmodule PredicatesTest do
  use Predicates.DataCase, async: true
  use ExUnit.Case, async: true
  import Assertions

  alias Predicates.PredicateConverter, as: Converter
  alias Predicates.PredicateError

  defmodule Post do
    @moduledoc false
    use Ecto.Schema

    schema "pred_posts" do
      field :name, :string
      field :likes, :integer
      field :publisher_id, :string
      field :meta, :map, default: %{}

      field :slug, :string, virtual: true

      belongs_to :author, PredicatesTest.Author

      timestamps type: :utc_datetime
    end

    def migrate do
      """
      CREATE TABLE #{:pred_posts} (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name text,
        likes int DEFAULT 0,
        publisher_id text,
        meta jsonb DEFAULT '{}',
        author_id int REFERENCES pred_authors(id) ON DELETE CASCADE ON UPDATE CASCADE,
        inserted_at timestamp with time zone NOT NULL default now(),
        updated_at timestamp with time zone NOT NULL default now()
      )
      """
    end

    def get_virtual_field(:slug),
      do:
        dynamic(
          [post],
          fragment("regexp_replace(lower(?), '[^a-z0-9\\-_]+', '-', 'gi')", post.name)
        )
  end

  defmodule Author do
    @moduledoc false
    use Ecto.Schema

    schema "pred_authors" do
      field :name, :string
      field :meta, :map, default: %{}
      field :birthday, :utc_datetime
      field :post_count, :integer, virtual: true
      field :oldest_post, :utc_datetime, virtual: true

      has_many :posts, Post
    end

    def migrate do
      """
      CREATE TABLE #{:pred_authors} (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name text NOT NULL,
        meta jsonb DEFAULT '{}',
        birthday timestamp with time zone
      )
      """
    end

    # Counts posts published with a given publisher
    def get_virtual_field(:post_count, %{"publisher_id" => publisher_id}),
      do:
        dynamic(
          subquery(
            from(p in Post,
              where:
                p.author_id == parent_as(:pred_authors).id and p.publisher_id == ^publisher_id,
              select: count(p.id)
            )
          )
        )

    def get_virtual_field(:oldest_post),
      do:
        dynamic(
          subquery(
            from(p in Post,
              where: p.author_id == parent_as(:pred_authors).id,
              order_by: [asc: p.inserted_at],
              limit: 1,
              select: p.inserted_at
            )
          )
        )
  end

  alias __MODULE__.Author
  alias __MODULE__.Post

  def create_tables(_) do
    Predicates.Repo.query!(Author.migrate(), [])
    Predicates.Repo.query!(Post.migrate(), [])

    :ok
  end

  setup :create_tables

  describe "operators" do
    test "queries by string equals/not-equals on string field" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{"op" => "eq", "path" => "name", "arg" => "Goethe"})
               |> Predicates.Repo.one()

      assert %{name: "Schiller"} =
               Converter.build_query(Author, %{
                 "op" => "not_eq",
                 "path" => "name",
                 "arg" => "Goethe"
               })
               |> Predicates.Repo.one()
    end

    test "queries by greater than on integer field" do
      Predicates.Repo.insert_all(Post, [%{name: "Post 1", likes: 0}, %{name: "Post 2", likes: 2}])

      assert [%{name: "Post 2", likes: 2}] =
               Converter.build_query(Post, %{"op" => "gt", "path" => "likes", "arg" => 0})
               |> Predicates.Repo.all()
    end

    test "not negates sub-predicate" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

      assert %{name: "Schiller"} =
               Converter.build_query(Author, %{
                 "op" => "not",
                 "arg" => %{"op" => "eq", "path" => "name", "arg" => "Goethe"}
               })
               |> Predicates.Repo.one()
    end

    test "fails on invalid/unknown operator" do
      assert_raise PredicateError, ~r/not supported/, fn ->
        Converter.build_query(Post, %{"op" => "invalid", "path" => "name", "arg" => "Foo"})
      end
    end

    test "comparing native fields with dates given as ISO string works" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", birthday: ~U[1749-08-28T00:00:00Z]},
        %{name: "Schiller", birthday: ~U[1759-11-10T00:00:00Z]}
      ])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "le",
                 "path" => "birthday",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.one()
    end

    test "comparing native fields with native DateTime works" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", birthday: ~U[1749-08-28T00:00:00Z]},
        %{name: "Schiller", birthday: ~U[1759-11-10T00:00:00Z]}
      ])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "le",
                 "path" => "birthday",
                 "arg" => ~U[1750-01-01T00:00:00.000Z]
               })
               |> Predicates.Repo.one()
    end

    test "comparing virtual fields with dates given as ISO string works" do
      {2, [goethe, schiller]} =
        Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}],
          returning: true
        )

      Predicates.Repo.insert_all(
        Post,
        [
          %{
            author_id: goethe.id,
            name: "Die Laune des Verliebten",
            inserted_at: ~U[1767-01-01T12:00:00Z]
          },
          %{
            author_id: goethe.id,
            name: "Die Mitschuldigen",
            inserted_at: ~U[1769-01-01T12:00:00Z]
          }
        ]
      )

      # Assert that it works for all relevant operators
      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "eq",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert_lists_equal [goethe, schiller],
                         Converter.build_query(Author, %{
                           "op" => "not_eq",
                           "path" => "oldest_post",
                           "arg" => "1750-01-01T00:00:00.000+0200"
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:id, :name])

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "contains",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "lt",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [goethe] ==
               Converter.build_query(Author, %{
                 "op" => "ge",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [goethe] ==
               Converter.build_query(Author, %{
                 "op" => "gt",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "in",
                 "path" => "oldest_post",
                 "arg" => ["1750-01-01T00:00:00.000+0200"]
               })
               |> Predicates.Repo.all()

      assert_lists_equal [goethe, schiller],
                         Converter.build_query(Author, %{
                           "op" => "not_in",
                           "path" => "oldest_post",
                           "arg" => ["1750-01-01T00:00:00.000+0200"]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:id, :name])
    end

    test "array in/not_in with integer array works" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", meta: %{"height" => 169}},
        %{name: "Schiller", meta: %{"height" => 179}}
      ])

      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "in",
                 "path" => "meta.height",
                 "arg" => [169, 170, 171]
               })
               |> Predicates.Repo.all()

      assert [%{name: "Schiller"}] =
               Converter.build_query(Author, %{
                 "op" => "not_in",
                 "path" => "meta.height",
                 "arg" => [169, 170, 171]
               })
               |> Predicates.Repo.all()
    end

    test "handling of null values in json fields and eq/not_eq operators" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", meta: %{"wealthy" => true}},
        %{name: "Mann", meta: %{"wealthy" => nil}},
        %{name: "Schiller", meta: %{}}
      ])

      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "eq",
                 "path" => "meta.wealthy",
                 "arg" => true
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "eq",
                 "path" => "meta.wealthy",
                 "arg" => "foo"
               })
               |> Predicates.Repo.all()

      assert_lists_equal [%{name: "Schiller"}, %{name: "Mann"}],
                         Converter.build_query(Author, %{
                           "op" => "eq",
                           "path" => "meta.wealthy",
                           "arg" => nil
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "not_eq",
                 "path" => "meta.wealthy",
                 "arg" => nil
               })
               |> Predicates.Repo.all()

      assert_lists_equal [%{name: "Schiller"}, %{name: "Mann"}],
                         Converter.build_query(Author, %{
                           "op" => "not_eq",
                           "path" => "meta.wealthy",
                           "arg" => true
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [%{name: "Schiller"}, %{name: "Mann"}, %{name: "Goethe"}],
                         Converter.build_query(Author, %{
                           "op" => "not_eq",
                           "path" => "meta.wealthy",
                           "arg" => "foo"
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])
    end

    test "handling of null values in json fields and in/not_in operators" do
      {3, [goethe, mann, schiller]} =
        Predicates.Repo.insert_all(
          Author,
          [
            %{name: "Goethe", meta: %{"wealthy" => true}, birthday: ~U[1749-08-28T00:00:00Z]},
            %{name: "Mann", meta: %{"wealthy" => nil}, birthday: nil},
            %{name: "Schiller", meta: %{}}
          ],
          returning: true
        )

      Predicates.Repo.insert_all(
        Post,
        [
          %{
            author_id: goethe.id,
            name: "Post 1",
            inserted_at: ~U[1767-01-01T12:00:00Z]
          },
          %{
            author_id: goethe.id,
            name: "Post 2",
            inserted_at: ~U[1767-01-02T12:00:00Z]
          }
        ]
      )

      # Single test
      assert_lists_equal [goethe],
                         Converter.build_query(Author, %{
                           "op" => "in",
                           "path" => "birthday",
                           "arg" => [~U[1749-08-28T00:00:00Z]]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [goethe, schiller, mann],
                         Converter.build_query(Author, %{
                           "op" => "in",
                           "path" => "birthday",
                           "arg" => [~U[1749-08-28T00:00:00Z], nil]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [schiller, mann],
                         Converter.build_query(Author, %{
                           "op" => "in",
                           "path" => "birthday",
                           "arg" => [nil]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [schiller, mann],
                         Converter.build_query(Author, %{
                           "op" => "not_in",
                           "path" => "birthday",
                           "arg" => [~U[1749-08-28T00:00:00Z]]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [],
                         Converter.build_query(Author, %{
                           "op" => "not_in",
                           "path" => "birthday",
                           "arg" => [~U[1749-08-28T00:00:00Z], nil]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [goethe],
                         Converter.build_query(Author, %{
                           "op" => "not_in",
                           "path" => "birthday",
                           "arg" => [nil]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      # Virtual test
      assert_lists_equal [schiller, mann],
                         Converter.build_query(
                           Author,
                           %{
                             "op" => "in",
                             "path" => "oldest_post",
                             "arg" => [nil]
                           }
                         )
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [goethe],
                         Converter.build_query(
                           Author,
                           %{
                             "op" => "not_in",
                             "path" => "oldest_post",
                             "arg" => [nil]
                           }
                         )
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      # JSON field tests
      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "in",
                 "path" => "meta.wealthy",
                 "arg" => [true]
               })
               |> Predicates.Repo.all()

      assert_lists_equal [%{name: "Schiller"}, %{name: "Mann"}, %{name: "Goethe"}],
                         Converter.build_query(Author, %{
                           "op" => "in",
                           "path" => "meta.wealthy",
                           "arg" => [true, nil]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert_lists_equal [%{name: "Mann"}, %{name: "Schiller"}],
                         Converter.build_query(Author, %{
                           "op" => "not_in",
                           "path" => "meta.wealthy",
                           "arg" => [true]
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "not_in",
                 "path" => "meta.wealthy",
                 "arg" => [true, nil]
               })
               |> Predicates.Repo.all()

      # Test that accessing nil fields in another logic clause doesn't "taint" the result
      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "or",
                 "args" => [
                   %{
                     "op" => "eq",
                     "path" => "meta.wealthy",
                     "arg" => true
                   },
                   %{
                     "op" => "in",
                     "path" => "meta.foo",
                     "arg" => [12, 42]
                   }
                 ]
               })
               |> Predicates.Repo.all()
    end

    test "using contains to check against array lists" do
      Predicates.Repo.insert_all(Post, [
        %{name: "Post 1", likes: 13, meta: %{"tags" => ["foo", "bar"]}},
        %{name: "Post 2", likes: 42, meta: %{"tags" => ["fizz", "buzz"]}}
      ])

      # as string
      assert %{name: "Post 1"} =
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => "bar"
               })
               |> Predicates.Repo.one()

      # as single element array
      assert %{name: "Post 2"} =
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => ["fizz"]
               })
               |> Predicates.Repo.one()

      # as multi element array where all elements must be present
      assert %{name: "Post 2"} =
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => ["fizz", "buzz"]
               })
               |> Predicates.Repo.one()

      # one array element not matching
      assert nil ==
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => ["fizz", "bar"]
               })
               |> Predicates.Repo.one()
    end

    test "starts_with and ends_with operators" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe"},
        %{name: "Schiller"},
        %{name: "Schmidt"}
      ])

      assert_lists_equal [%{name: "Schiller"}, %{name: "Schmidt"}],
                         Converter.build_query(Author, %{
                           "op" => "starts_with",
                           "path" => "name",
                           "arg" => "Sch"
                         })
                         |> Predicates.Repo.all(),
                         &assert_maps_equal(&1, &2, [:name])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "ends_with",
                 "path" => "name",
                 "arg" => "the"
               })
               |> Predicates.Repo.one()
    end
  end

  test "supports shorthand true/false expressions" do
    Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

    assert 2 ==
             Converter.build_query(Author, %{"arg" => true})
             |> Predicates.Repo.aggregate(:count)

    assert 0 ==
             Converter.build_query(Author, %{"arg" => false})
             |> Predicates.Repo.aggregate(:count)
  end

  describe "paths" do
    test "resolves field using get_virtual_field/1" do
      Predicates.Repo.insert_all(Post, [%{name: "Post 1"}, %{name: "Post 2"}])

      assert %{name: "Post 1"} =
               Converter.build_query(Post, %{"op" => "eq", "path" => "slug", "arg" => "post-1"})
               |> Predicates.Repo.one()
    end

    test "resolves field using get_virtual_field/2" do
      {1, [goethe]} = Predicates.Repo.insert_all(Author, [%{name: "Goethe"}], returning: true)

      Predicates.Repo.insert_all(Post, [
        %{name: "Faust", publisher_id: "suhrkamp", author_id: goethe.id},
        %{name: "Gedichte", publisher_id: "reclam", author_id: goethe.id}
      ])

      assert goethe ==
               Converter.build_query(
                 Author,
                 %{"op" => "eq", "path" => "post_count", "arg" => 1},
                 %{
                   "publisher_id" => "suhrkamp"
                 }
               )
               |> Predicates.Repo.one()
    end

    test "resolves path into json field" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe", meta: %{born: 1749}}])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{"op" => "lt", "path" => "meta.born", "arg" => 1800})
               |> Predicates.Repo.one()
    end

    test "walks association" do
      {2, [goethe, schiller]} =
        Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}],
          returning: true
        )

      Predicates.Repo.insert_all(Post, [
        %{name: "Faust", author_id: goethe.id},
        %{name: "Maria Stuart", author_id: schiller.id}
      ])

      assert goethe ==
               Converter.build_query(Author, %{
                 "op" => "like",
                 "path" => "posts.name",
                 "arg" => "Fau"
               })
               |> Predicates.Repo.one()

      # using contains alias
      assert goethe ==
               Converter.build_query(Author, %{
                 "op" => "contains",
                 "path" => "posts.name",
                 "arg" => "Fau"
               })
               |> Predicates.Repo.one()
    end
  end

  describe "any" do
    test "get posts filtered of an author" do
      {2, [goethe, schiller]} =
        Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}],
          returning: true
        )

      Predicates.Repo.insert_all(Post, [
        %{name: "Post 1", likes: 13, author_id: schiller.id},
        %{name: "Post 2", likes: 42, author_id: goethe.id}
      ])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "any",
                 "path" => "posts",
                 "arg" => %{
                   "op" => "gt",
                   "path" => "likes",
                   "arg" => 20
                 }
               })
               |> Predicates.Repo.one()
    end
  end

  describe "conjunctions" do
    test "empty args for 'and' evals to true" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

      assert 2 ==
               Converter.build_query(Author, %{"op" => "and", "args" => []})
               |> Predicates.Repo.aggregate(:count)
    end

    test "empty args for 'or' evals to false" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

      assert 0 ==
               Converter.build_query(Author, %{"op" => "or", "args" => []})
               |> Predicates.Repo.aggregate(:count)
    end
  end

  describe "pattern escaping" do
    for op <- ["like", "ilike", "starts_with", "ends_with"] do
      test "uses escaped patterns for #{op} operator" do
        Predicates.Repo.insert_all(Author, [
          %{name: "Goethe"},
          %{name: "Schiller"},
          %{name: "Sch%ller"},
          %{name: "Sch_ller"}
        ])

        assert [%{name: "Sch%ller"}] =
                 Converter.build_query(Author, %{
                   "op" => unquote(op),
                   "path" => "name",
                   "arg" => "Sch%ller"
                 })
                 |> Predicates.Repo.all()

        assert [%{name: "Sch_ller"}] =
                 Converter.build_query(Author, %{
                   "op" => unquote(op),
                   "path" => "name",
                   "arg" => "Sch_ller"
                 })
                 |> Predicates.Repo.all()
      end
    end
  end

  # TODO: Test client_id filter for association subqueries
end
