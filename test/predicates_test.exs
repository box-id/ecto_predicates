defmodule PredicatesTest do
  use Predicates.DataCase, async: true
  use ExUnit.Case, async: true
  import Assertions

  alias Predicates.PredicateConverter, as: Converter
  alias Predicates.PredicateError

  defmodule Post do
    @moduledoc false
    use Ecto.Schema

    schema "pred_posts" do
      field(:name, :string)
      field(:likes, :integer)
      field(:publisher_id, :string)
      field(:meta, :map, default: %{})

      field(:slug, :string, virtual: true)

      belongs_to(:author, PredicatesTest.Author)

      timestamps(type: :utc_datetime)
    end

    def migrate do
      """
      CREATE TABLE #{:pred_posts} (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name text,
        likes int DEFAULT 0,
        publisher_id text,
        meta jsonb DEFAULT '{}',
        author_id int REFERENCES pred_authors(id) ON DELETE CASCADE ON UPDATE CASCADE,
        inserted_at timestamp with time zone NOT NULL default now(),
        updated_at timestamp with time zone NOT NULL default now()
      )
      """
    end

    def get_virtual_field(:slug),
      do:
        dynamic(
          [post],
          fragment("regexp_replace(lower(?), '[^a-z0-9\\-_]+', '-', 'gi')", post.name)
        )
  end

  defmodule Author do
    @moduledoc false
    use Ecto.Schema

    schema "pred_authors" do
      field(:name, :string)
      field(:meta, :map, default: %{})

      field(:post_count, :integer, virtual: true)

      field(:birthday, :utc_datetime)

      field(:oldest_post, :utc_datetime, virtual: true)

      has_many(:posts, Post)
    end

    def migrate do
      """
      CREATE TABLE #{:pred_authors} (
        id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        name text NOT NULL,
        meta jsonb DEFAULT '{}',
        birthday timestamp with time zone
      )
      """
    end

    # Counts posts published with a given publisher
    def get_virtual_field(:post_count, %{"publisher_id" => publisher_id}),
      do:
        dynamic(
          [author],
          subquery(
            from(p in Post,
              where:
                p.author_id == parent_as(:pred_authors).id and p.publisher_id == ^publisher_id,
              select: count(p.id)
            )
          )
        )

    def get_virtual_field(:oldest_post),
      do:
        dynamic(
          [author],
          subquery(
            from(p in Post,
              where: p.author_id == parent_as(:pred_authors).id,
              order_by: [asc: p.inserted_at],
              limit: 1,
              select: p.inserted_at
            )
          )
        )
  end

  alias __MODULE__.Author
  alias __MODULE__.Post

  def create_tables(_) do
    Predicates.Repo.query!(Author.migrate(), [])
    Predicates.Repo.query!(Post.migrate(), [])

    :ok
  end

  setup :create_tables

  describe "operators" do
    test "queries by string equals on string field" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{"op" => "eq", "path" => "name", "arg" => "Goethe"})
               |> Predicates.Repo.one()
    end

    test "queries by greater than on integer field" do
      Predicates.Repo.insert_all(Post, [%{name: "Post 1", likes: 0}, %{name: "Post 2", likes: 2}])

      assert [%{name: "Post 2", likes: 2}] =
               Converter.build_query(Post, %{"op" => "gt", "path" => "likes", "arg" => 0})
               |> Predicates.Repo.all()
    end

    test "not negates sub-predicate" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

      assert %{name: "Schiller"} =
               Converter.build_query(Author, %{
                 "op" => "not",
                 "arg" => %{"op" => "eq", "path" => "name", "arg" => "Goethe"}
               })
               |> Predicates.Repo.one()
    end

    test "fails on invalid/unknown operator" do
      assert_raise PredicateError, ~r/not supported/, fn ->
        Converter.build_query(Post, %{"op" => "invalid", "path" => "name", "arg" => "Foo"})
      end
    end

    test "comparing native fields with dates given as ISO string works" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", birthday: ~U[1749-08-28T00:00:00Z]},
        %{name: "Schiller", birthday: ~U[1759-11-10T00:00:00Z]}
      ])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "le",
                 "path" => "birthday",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.one()
    end

    test "comparing native fields with native DateTime works" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", birthday: ~U[1749-08-28T00:00:00Z]},
        %{name: "Schiller", birthday: ~U[1759-11-10T00:00:00Z]}
      ])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "le",
                 "path" => "birthday",
                 "arg" => ~U[1750-01-01T00:00:00.000Z]
               })
               |> Predicates.Repo.one()
    end

    test "comparing virtual fields with dates given as ISO string works" do
      # Assert that it works for all relevant operators
      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "eq",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "contains",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "lt",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "ge",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "gt",
                 "path" => "oldest_post",
                 "arg" => "1750-01-01T00:00:00.000+0200"
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "in",
                 "path" => "oldest_post",
                 "arg" => ["1750-01-01T00:00:00.000+0200"]
               })
               |> Predicates.Repo.all()

      assert [] ==
               Converter.build_query(Author, %{
                 "op" => "not_in",
                 "path" => "oldest_post",
                 "arg" => ["1750-01-01T00:00:00.000+0200"]
               })
               |> Predicates.Repo.all()
    end

    test "array in/not_in with integer array works" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", meta: %{"height" => 169}},
        %{name: "Schiller", meta: %{"height" => 179}}
      ])

      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "in",
                 "path" => "meta.height",
                 "arg" => [169, 170, 171]
               })
               |> Predicates.Repo.all()

      assert [%{name: "Schiller"}] =
               Converter.build_query(Author, %{
                 "op" => "not_in",
                 "path" => "meta.height",
                 "arg" => [169, 170, 171]
               })
               |> Predicates.Repo.all()
    end

    test "handling of null values in json fields" do
      Predicates.Repo.insert_all(Author, [
        %{name: "Goethe", meta: %{"wealthy" => true}},
        %{name: "Mann", meta: %{"wealthy" => nil}},
        %{name: "Schiller", meta: %{}}
      ])

      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "eq",
                 "path" => "meta.wealthy",
                 "arg" => true
               })
               |> Predicates.Repo.all()

      assert_lists_equal(
        [%{name: "Schiller"}, %{name: "Mann"}],
        Converter.build_query(Author, %{
          "op" => "eq",
          "path" => "meta.wealthy",
          "arg" => nil
        })
        |> Predicates.Repo.all(),
        &assert_maps_equal(&1, &2, [:name])
      )

      # Nil checks are special-cased on `eq` operator and not supported on other operators, which is why Schiller and
      # Mann are missing from the following results.
      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "in",
                 "path" => "meta.wealthy",
                 "arg" => [true, nil]
               })
               |> Predicates.Repo.all()

      # Interesting enough, `not_in` is not the inverse of `in` if null values are involved:
      assert [] =
               Converter.build_query(Author, %{
                 "op" => "not_in",
                 "path" => "meta.wealthy",
                 "arg" => [true, nil]
               })
               |> Predicates.Repo.all()

      # Test that accessing nil fields in another logic clause doesn't "taint" the result
      assert [%{name: "Goethe"}] =
               Converter.build_query(Author, %{
                 "op" => "or",
                 "args" => [
                   %{
                     "op" => "eq",
                     "path" => "meta.wealthy",
                     "arg" => true
                   },
                   %{
                     "op" => "in",
                     "path" => "meta.foo",
                     "arg" => [12, 42]
                   }
                 ]
               })
               |> Predicates.Repo.all()
    end

    test "using contains to check against array lists" do
      Predicates.Repo.insert_all(Post, [
        %{name: "Post 1", likes: 13, meta: %{"tags" => ["foo", "bar"]}},
        %{name: "Post 2", likes: 42, meta: %{"tags" => ["fizz", "buzz"]}}
      ])

      # as string
      assert %{name: "Post 1"} =
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => "bar"
               })
               |> Predicates.Repo.one()

      # as single element array
      assert %{name: "Post 2"} =
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => ["fizz"]
               })
               |> Predicates.Repo.one()

      # as multi element array where all elements must be present
      assert %{name: "Post 2"} =
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => ["fizz", "buzz"]
               })
               |> Predicates.Repo.one()

      # one array element not matching
      assert nil ==
               Converter.build_query(Post, %{
                 "op" => "contains",
                 "path" => "meta.tags",
                 "arg" => ["fizz", "bar"]
               })
               |> Predicates.Repo.one()
    end
  end

  test "supports shorthand true/false expressions" do
    Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}])

    assert 2 ==
             Converter.build_query(Author, %{"arg" => true})
             |> Predicates.Repo.aggregate(:count)

    assert 0 ==
             Converter.build_query(Author, %{"arg" => false})
             |> Predicates.Repo.aggregate(:count)
  end

  describe "paths" do
    test "resolves field using get_virtual_field/1" do
      Predicates.Repo.insert_all(Post, [%{name: "Post 1"}, %{name: "Post 2"}])

      assert %{name: "Post 1"} =
               Converter.build_query(Post, %{"op" => "eq", "path" => "slug", "arg" => "post-1"})
               |> Predicates.Repo.one()
    end

    test "resolves field using get_virtual_field/2" do
      {1, [goethe]} = Predicates.Repo.insert_all(Author, [%{name: "Goethe"}], returning: true)

      Predicates.Repo.insert_all(Post, [
        %{name: "Faust", publisher_id: "suhrkamp", author_id: goethe.id},
        %{name: "Gedichte", publisher_id: "reclam", author_id: goethe.id}
      ])

      assert goethe ==
               Converter.build_query(
                 Author,
                 %{"op" => "eq", "path" => "post_count", "arg" => 1},
                 %{
                   "publisher_id" => "suhrkamp"
                 }
               )
               |> Predicates.Repo.one()
    end

    test "resolves path into json field" do
      Predicates.Repo.insert_all(Author, [%{name: "Goethe", meta: %{born: 1749}}])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{"op" => "lt", "path" => "meta.born", "arg" => 1800})
               |> Predicates.Repo.one()
    end

    test "walks association" do
      {2, [goethe, schiller]} =
        Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}],
          returning: true
        )

      Predicates.Repo.insert_all(Post, [
        %{name: "Faust", author_id: goethe.id},
        %{name: "Maria Stuart", author_id: schiller.id}
      ])

      assert goethe ==
               Converter.build_query(Author, %{
                 "op" => "like",
                 "path" => "posts.name",
                 "arg" => "Fau"
               })
               |> Predicates.Repo.one()

      # using contains alias
      assert goethe ==
               Converter.build_query(Author, %{
                 "op" => "contains",
                 "path" => "posts.name",
                 "arg" => "Fau"
               })
               |> Predicates.Repo.one()
    end
  end

  describe "any" do
    test "get posts filtered of an author" do
      {2, [goethe, schiller]} =
        Predicates.Repo.insert_all(Author, [%{name: "Goethe"}, %{name: "Schiller"}],
          returning: true
        )

      Predicates.Repo.insert_all(Post, [
        %{name: "Post 1", likes: 13, author_id: schiller.id},
        %{name: "Post 2", likes: 42, author_id: goethe.id}
      ])

      assert %{name: "Goethe"} =
               Converter.build_query(Author, %{
                 "op" => "any",
                 "path" => "posts",
                 "arg" => %{
                   "op" => "gt",
                   "path" => "likes",
                   "arg" => 20
                 }
               })
               |> Predicates.Repo.one()
    end
  end

  # TODO: Test client_id filter for association subqueries
end
